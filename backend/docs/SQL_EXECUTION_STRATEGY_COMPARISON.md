# SQL 执行策略对比

**日期**: 2025-10-26
**问题**: Agent 如何在生成 SQL 后验证其正确性？

---

## 🎯 核心问题

在优化工具配置时，我们移除了 `SQLExecuteTool` 以避免频繁连接数据库。但这导致：

- ❌ Agent 无法执行 SQL 验证结果
- ❌ Agent 无法根据执行错误进行迭代优化
- ❌ Agent 无法验证返回的数据是否符合预期

---

## 💡 方案对比

### 方案 1：纯静态验证（当前方案）

**流程**：
```
ReAct 阶段:
  Schema 探索 → SQL 生成 → 静态验证（不执行）

ETL 阶段:
  Orchestrator 执行 SQL → 返回结果或错误
```

**优点**：
- ✅ 不频繁连接数据库，稳定性高
- ✅ 响应速度快（100-500x 提升）
- ✅ Token 消耗少（无需存储执行结果）

**缺点**：
- ❌ 无法验证 SQL 执行是否成功
- ❌ 无法根据执行错误迭代优化
- ❌ 如果 SQL 有问题，只能在 ETL 阶段才发现

**适用场景**：
- Schema 信息完整准确
- SQL 逻辑相对简单
- 数据源连接稳定

---

### 方案 2：允许 Agent 执行 SQL（原始方案）

**流程**：
```
ReAct 阶段:
  Schema 探索 → SQL 生成 → 执行 SQL → 查看结果 → 优化 SQL
  (可能多次迭代)

ETL 阶段:
  Orchestrator 执行最终 SQL
```

**优点**：
- ✅ Agent 可以看到真实执行结果
- ✅ 可以根据错误信息迭代优化
- ✅ 可以验证数据是否符合预期
- ✅ 生成的 SQL 质量更高

**缺点**：
- ❌ 频繁连接数据库（每次执行都连接）
- ❌ 如果数据库连接不稳定，ReAct 流程会失败
- ❌ Token 消耗大（需要存储执行结果）
- ❌ 响应时间长（等待 SQL 执行）

**适用场景**：
- SQL 逻辑复杂，需要多次调整
- 对 SQL 质量要求高
- 数据源连接稳定可靠

---

### 方案 3：混合策略（推荐）⭐

**流程**：
```
ReAct 阶段 (尝试 1):
  Schema 探索 → SQL 生成 → 静态验证（不执行）

ETL 阶段:
  Orchestrator 执行 SQL
  ├─ 成功 → 返回结果 ✅
  └─ 失败 → 触发重试

ReAct 阶段 (尝试 2):
  提供错误信息 → Agent 分析错误 → 生成新 SQL → 执行验证 (限制 1 次)

ETL 阶段 (重试):
  Orchestrator 执行新 SQL
```

**优点**：
- ✅ 大部分情况下不连接数据库（快速、稳定）
- ✅ 只在失败时才执行 SQL 验证（容错性高）
- ✅ Agent 可以根据真实错误进行修正
- ✅ 平衡了性能和准确性

**缺点**：
- ⚠️ 实现稍微复杂（需要重试机制）
- ⚠️ 仍有小概率连接数据库

**实现要点**：
1. 第一次生成：只用静态验证
2. 如果执行失败：
   - 提取错误信息（SQL 语法错误、列不存在等）
   - 重新调用 Agent，提供错误上下文
   - 允许 Agent 执行 **1 次** SQL 验证
3. 限制重试次数（最多 1 次）

---

### 方案 4：采样执行策略（创新方案）

**流程**：
```
ReAct 阶段:
  Schema 探索 → SQL 生成 → 添加 LIMIT 10 → 执行采样 → 验证结果格式

ETL 阶段:
  Orchestrator 执行完整 SQL（无 LIMIT）
```

**优点**：
- ✅ 可以验证 SQL 语法正确性
- ✅ 可以验证返回数据格式
- ✅ 执行速度快（只查 10 条）
- ✅ 数据库负载低

**缺点**：
- ⚠️ 仍需连接数据库
- ⚠️ 无法验证完整数据集的正确性

**适用场景**：
- 需要验证 SQL 语法和数据格式
- 但不关心完整数据集

---

## 📊 方案对比表

| 维度            | 方案1: 纯静态 | 方案2: 总是执行 | 方案3: 混合 ⭐ | 方案4: 采样 |
|---------------|-----------|-----------|------------|---------|
| **响应速度**      | 🟢 极快      | 🔴 慢       | 🟢 快       | 🟡 中等    |
| **稳定性**       | 🟢 极高      | 🔴 低       | 🟢 高       | 🟡 中等    |
| **SQL 质量**    | 🟡 中等      | 🟢 高       | 🟢 高       | 🟢 高     |
| **Token 消耗**  | 🟢 低       | 🔴 高       | 🟡 中等      | 🟡 中等    |
| **数据库连接次数**   | 🟢 0 次     | 🔴 多次      | 🟡 0-1 次   | 🟡 1 次   |
| **实现复杂度**     | 🟢 简单      | 🟢 简单      | 🟡 中等      | 🟢 简单    |
| **容错能力**      | 🔴 低       | 🟢 高       | 🟢 高       | 🟢 高     |

---

## 🎯 推荐方案：方案 3（混合策略）

**理由**：
1. **90% 的场景**：静态验证足够，不连接数据库，快速稳定
2. **10% 的场景**：SQL 有问题时，允许执行一次验证并修正
3. **平衡性最好**：兼顾性能、稳定性、准确性

**实现步骤**：
1. 在 orchestrator 中捕获 SQL 执行错误
2. 如果失败，提取错误信息
3. 重新调用 Agent，提供错误上下文
4. 在这次调用中，临时允许使用 `SQLExecuteTool`（限制 1 次调用）
5. Agent 修正 SQL 并验证
6. 返回新的 SQL

---

## 💬 总结

**当前方案（方案 1）的问题**：
- 无法处理复杂 SQL 场景
- 遇到错误只能人工介入

**建议升级到方案 3**：
- 保留方案 1 的性能优势
- 增加错误处理和自动修正能力
- 最小化数据库连接次数
- 提高整体成功率

**下一步行动**：
1. 实现 orchestrator 的错误捕获和重试机制
2. 添加 "允许执行 SQL" 的条件开关
3. 限制 Agent 执行 SQL 的次数（最多 1 次）
4. 添加详细的错误日志和监控

